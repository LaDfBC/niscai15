/** 
 * Generated by Creer at 02:31PM on October 26, 2015 UTC, git hash: '98604e3773d1933864742cb78acbf6ea0b4ecd7b'
 * This is where you build your AI for the Checkers game.
 */
package games.checkers;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import joueur.BaseAI;
// <<-- Creer-Merge: imports -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
import java.util.List;
// <<-- /Creer-Merge: imports -->>
@SuppressWarnings("unused")

/**
 * This is where you build your AI for the Checkers game.
 */
public class AI extends BaseAI {
    /**
     * This is the Game object itself, it contains all the information about the current game
     */
    public Game game;

    /**
     * This is your AI's player. This AI class is not a player, but it should command this Player.
     */
    public Player player;

    // <<-- Creer-Merge: fields -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
    private class Point {
        int x = -1;
        int y = -1;
        boolean requiresJump = false;
    }
    
    private class MoveData {
        Checker checker = null;
        Point point = null;
    }
    
    private boolean cantMove = false;
    private Checker forceChecker = null;
    private Checker[][] checkersMap;
    // <<-- /Creer-Merge: fields -->>


    /**
     * This returns your AI's name to the game server. Just replace the string.
     * @return string of you AI's name
     */
    public String getName() {
        // <<-- Creer-Merge: get-name -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        return "Checkers java Player"; // REPLACE THIS WITH YOUR TEAM NAME!
        // <<-- /Creer-Merge: get-name -->>
    }

    /**
     * This is automatically called when the game first starts, once the Game object and all GameObjects have been initialized, but before any players do anything.
     * This is a good place to initialize any variables you add to your AI, or start tracking game objects.
     */
    public void start() {
        // <<-- Creer-Merge: start -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        this.checkersMap = new Checker[this.game.boardWidth][this.game.boardHeight];
        
        this.clearCheckersMap();
        // <<-- /Creer-Merge: start -->>
    }

    /**
     * This is automatically called every time the game (or anything in it) updates.
     * If a function you call triggers an update this will be called before that function returns.
     */
    public void gameUpdated() {
        // <<-- Creer-Merge: game-updated -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        this.clearCheckersMap();
        
        this.forceChecker = null;
        this.cantMove = false;
        
        for(int i = 0; i < this.game.checkers.size(); i++) {
            Checker checker = this.game.checkers.get(i);
            this.checkersMap[checker.x][checker.y] = checker;
            
            if(checker.owner == this.player && checker == this.game.checkerMoved) {
                if(this.game.checkerMovedJumped) {
                    this.forceChecker = checker;
                }
                else {
                    this.cantMove = true;
                }
            }
        }
        // <<-- /Creer-Merge: game-updated -->>
    }

    /**
     * This is automatically called when the game ends.
     * You can do any cleanup of you AI here, or do custom logging. After this function returns the application will close.
     * @param  won  true if your player won, false otherwise
     * @param  name  reason">a string explaining why you won or lost
     */
    public void ended(boolean won, String reason) {
        // <<-- Creer-Merge: ended -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        super.ended(won, reason);
        // <<-- /Creer-Merge: ended -->>
    }


    /**
     * This is called every time the AI is asked to respond with a command during their turn
     *
     * @return represents if you want to end your turn. true means end the turn, false means to keep your turn going and re-call runTurn()
     */
    public boolean runTurn() {
        // <<-- Creer-Merge: runTurn -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        while(true) {
            MoveData moveData = this.findMove();
            
            if (moveData != null) {
                moveData.checker.move(moveData.point.x, moveData.point.y);
            }
            else {
                break;
            }
        }
        
        return true;
        // <<-- /Creer-Merge: runTurn -->>
    }


    // <<-- Creer-Merge: methods -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
    
    private MoveData findMove() {
        if (this.cantMove) {
            return null;
        }
        
        List<Checker> checkers = new ArrayList<Checker>();
        
        if (this.forceChecker != null) {
            checkers.add(this.forceChecker);
        }
        else {
            checkers.addAll(0, this.player.checkers);
        }
        
        final int yDirection = this.player.yDirection;
        
        java.util.Collections.shuffle(checkers);
        
        for(int i = 0; i < checkers.size(); i++) {
            final Checker checker = checkers.get(i);
            MoveData moveData = new MoveData();
            List<Point> neighbors = new ArrayList<Point>();
            neighbors.add(new Point() { { x = checker.x + 1; y = checker.y + yDirection; } });
            neighbors.add(new Point() { { x = checker.x - 1; y = checker.y + yDirection; } });
            
            if(checker.kinged) {
                neighbors.add(new Point() { { x = checker.x + 1; y = checker.y - yDirection; } });
                neighbors.add(new Point() { { x = checker.x - 1; y = checker.y - yDirection; } });
            }
            
            java.util.Collections.shuffle(neighbors);
            
            while(neighbors.size() > 0) {
                final Point neighbor = neighbors.get(0);
                neighbors.remove(0);
                
                if (neighbor.x >= this.game.boardWidth || neighbor.x < 0 || neighbor.y >= this.game.boardHeight || neighbor.y < 0) {
                    continue;
                }
                
                if (this.forceChecker != null) { // then we MUST jump
                    if (neighbor.requiresJump) { // and we can!
                        moveData.checker = checker;
                        moveData.point = neighbor;
                        return moveData;
                    }
                }
                else {
                    Checker jumping = this.checkersMap[neighbor.x][neighbor.y];
                    if (jumping == null) { // then the space is empty, and safe!
                        moveData.checker = checker;
                        moveData.point = neighbor;
                        return moveData;
                    }
                    else if (jumping.owner != checker.owner) { // there is one to jump, so let's try to jump it
                        if (!neighbor.requiresJump) {
                            final int dx = neighbor.x - checker.x;
                            final int dy = neighbor.y - checker.y;
                            
                            neighbors.add(new Point() {{ x = neighbor.x + dx; y = neighbor.y + dy; requiresJump = true; }});
                        }
                    }
                }
            }
        }
        
        return null; // because a checker was not found that can move :(
    }
    
    private void clearCheckersMap() {
        for(int x = 0; x < this.game.boardWidth; x++) {
            for(int y = 0; y < this.game.boardHeight; y++) {
                this.checkersMap[x][y] = null;
            }
        }
    }
    
    // <<-- /Creer-Merge: methods -->>
}
