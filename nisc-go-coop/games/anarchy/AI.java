/** 
 * Generated by Creer at 03:01PM on November 10, 2015 UTC, git hash: '1b69e788060071d644dd7b8745dca107577844e1'
 * This is where you build your AI for the Anarchy game.
 */
package games.anarchy;

import java.util.*;

import games.anarchy.Strategy.Building.*;
import games.anarchy.Strategy.Heuristic.Pair;
import games.anarchy.Strategy.Heuristic.WeatherOffsense;
import joueur.BaseAI;

import javax.print.DocFlavor;
import javax.smartcardio.Card;

// <<-- Creer-Merge: imports -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
// you can add addtional import(s) here
// <<-- /Creer-Merge: imports -->>
@SuppressWarnings("unused")

/**
 * This is where you build your AI for the Anarchy game.
 */
public class AI extends BaseAI {
    /**
     * This is the Game object itself, it contains all the information about the current game
     */
    public Game game;

    /**
     * This is your AI's player. This AI class is not a player, but it should command this Player.
     */
    public Player player;



    // <<-- Creer-Merge: fields -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
    public Warehouse myHeadquarters;
    public Warehouse enemyHeadquarters;
    List<Warehouse> myAttackers;
    List<Warehouse> enemyAttackers;

    WarehouseUtilities warehouseUtilities;
    WeatherStationUtilities weatherStationUtilities;
    EnemyHeadquartersUtilities enemyHeadquartersUtilities;
    PoliceDepartmentUtilities policeDepartmentUtilities;
    FriendlyHeadquartersUtilities friendlyHeadquartersUtilities;
    // <<-- /Creer-Merge: fields -->>


    /**
     * This returns your AI's name to the game server. Just replace the string.
     * @return string of you AI's name
     */
    public String getName() {
        // <<-- Creer-Merge: get-name -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        return "NISC - GO COOP - BUGFIX"; // REPLACE THIS WITH YOUR TEAM NAME!
        // <<-- /Creer-Merge: get-name -->>
    }

    /**
     * This is automatically called when the game first starts, once the Game object and all GameObjects have been initialized, but before any players do anything.
     * This is a good place to initialize any variables you add to your AI, or start tracking game objects.
     */
    public void start() {
        // <<-- Creer-Merge: start -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        super.start();
        for(Warehouse warehouse : player.warehouses) {
            if(warehouse.isHeadquarters) {
                myHeadquarters = warehouse;
                break;
            }
        }

        for(Warehouse warehouse : player.otherPlayer.warehouses) {
            if(warehouse.isHeadquarters) {
                enemyHeadquarters = warehouse;
                break;
            }
        }
        warehouseUtilities = new WarehouseUtilities(player);
        weatherStationUtilities = new WeatherStationUtilities(player, game);
        enemyHeadquartersUtilities = new EnemyHeadquartersUtilities(enemyHeadquarters, game);
        policeDepartmentUtilities = new PoliceDepartmentUtilities(player.policeDepartments, enemyHeadquartersUtilities);
        friendlyHeadquartersUtilities = new FriendlyHeadquartersUtilities(player.headquarters, game);
        // <<-- /Creer-Merge: start -->>
    }

    /**
     * This is automatically called every time the game (or anything in it) updates.
     * If a function you call triggers an update this will be called before that function returns.
     */
    public void gameUpdated() {
        // <<-- Creer-Merge: game-updated -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        super.gameUpdated();
        // <<-- /Creer-Merge: game-updated -->>
    }

    /**
     * This is automatically called when the game ends.
     * You can do any cleanup of you AI here, or do custom logging. After this function returns the application will close.
     * @param  won  true if your player won, false otherwise
     * @param  reason">a string explaining why you won or lost
     */
    public void ended(boolean won, String reason) {
        // <<-- Creer-Merge: ended -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        super.ended(won, reason);
        // <<-- /Creer-Merge: ended -->>
    }

    public void weatherFiddle() {

    }

    public void georgeFiddle() {
        focusedBurnStrategy();
    }

    public void joeFiddle(){
        EnemyHeadquartersUtilities enemyHeadquartersUtilities = new EnemyHeadquartersUtilities(enemyHeadquarters, game);


        Building enemyEhqNeighbor = null;
        Map<Building,WeatherStationUtilities.CardinalDirection> enemyHqNeighbor = enemyHeadquartersUtilities.getEnemyHeadquartersNeighbors();
        for( Map.Entry<Building,WeatherStationUtilities.CardinalDirection> enemyneighbor : enemyHqNeighbor.entrySet()){
            if(enemyneighbor != null && enemyneighbor.getKey().health > 0){
                enemyEhqNeighbor = enemyneighbor.getKey();
                break;
            }
        }
        if(enemyEhqNeighbor != null) {
            List<Warehouse> myAttackers = player.warehouses;

            while (player.bribesRemaining > 0) {
                Warehouse myAttacker = warehouseUtilities.getClosestWarehouse(enemyEhqNeighbor, myAttackers);
                if(myAttacker != null){
                    myAttacker.ignite(enemyEhqNeighbor);
                    myAttackers.remove(myAttacker);
                }
            }
        }
    }


    public void jeffWeather() {
        WeatherStationUtilities weather = new WeatherStationUtilities(player,game);
        WeatherOffsense weatherAttack = new WeatherOffsense(player,weather,game);
        //ignite warehouses closest to their HQ
        igniteBuildingsCloseToHQ(6, 7);

        //delegate up to 4 turns for the weather
        weatherAttack.minMaxDamage(3);
        while (player.bribesRemaining > 0) {
            igniteBuildingsCloseToHQ(6, 7);
        }
    }


    public void jeffWeather2() {
        WeatherStationUtilities weather = new WeatherStationUtilities(player,game);
        WeatherOffsense weatherAttack = new WeatherOffsense(player,weather,game);

        igniteBuildingsCloseToHQ(4,1);
        weatherAttack.minMaxDamage(6);
        while (player.bribesRemaining > 0) {
            igniteBuildingsCloseToHQ(4,1);
        }
    }

    public void igniteBuildingsCloseToHQ(int numBuildings, int maxDistance) {
        //ignite warehouses closest to their HQ
        List<Building> closeBuildings = enemyHeadquarters.getBuildingsWithinDistance(maxDistance);

        Queue<Building> closeEnemies = new ArrayDeque<>();
        for (Building b : closeBuildings) {
            if (b.owner != player) {
                closeEnemies.add(b);
            }
        }

        Set<Warehouse> bribeableWarehouses = warehouseUtilities.getBribeableWarehouses();

        //ignite
        int numTurns = numBuildings;
        while (numTurns > 0) {
            if (!closeEnemies.isEmpty()) {
                Building buildingToFire = closeEnemies.poll();
                //get the closest warehouse to this building that is still usable
                Warehouse whToAttackWIth = warehouseUtilities.getClosestWarehouse(buildingToFire, bribeableWarehouses);
                if (whToAttackWIth != null && player.bribesRemaining > 0) {
                    whToAttackWIth.ignite(buildingToFire);
                    bribeableWarehouses.remove(whToAttackWIth);
                }
            }
            numTurns--;
        }
    }

    public Building focusedBurnStrategy() {
//        return enemyHeadquarters;
        //If we go on turn two, we want to NOT blow in the same direction the other dude is blowing
        // We'd ALSO like to ignite the fire he's (probably) going to fan in our face

        //Logic for choosing a different direction.....First load all friendly buildings on fire.
        Map<Building, WeatherStationUtilities.CardinalDirection> friendlyNeighbors = friendlyHeadquartersUtilities.getFriendlyHeadquartersNeighbors();
        List<Building> surroundingBuildingsOnFire = new ArrayList<>();
        for(Map.Entry<Building, WeatherStationUtilities.CardinalDirection> friendlyHeadquartersNeightbor : friendlyNeighbors.entrySet()) {
            if(friendlyHeadquartersNeightbor.getKey().fire > 0 || friendlyHeadquartersNeightbor.getKey().isHeadquarters) {
                surroundingBuildingsOnFire.add(friendlyHeadquartersNeightbor.getKey());
            }
        }

        //Remove them from the list of options.  If all buildings are on fire, just choose one of theirs at random.
        if(surroundingBuildingsOnFire.size() < friendlyNeighbors.size()) {
            for(Building neighbor : surroundingBuildingsOnFire) {
                friendlyNeighbors.remove(neighbor);
            }
        } else { //Use the building on their side with the least fire on our side
            if(friendlyNeighbors.get(myHeadquarters) != null) {
                friendlyNeighbors.remove(myHeadquarters);
            }
            Collections.sort(surroundingBuildingsOnFire, new Comparator<Building>() {
                @Override
                public int compare(Building o1, Building o2) {
                    if (o1.fire > o2.fire) {
                        return 1;
                    } else if (o1.fire < o2.fire) {
                        return -1;
                    }
                    return 0;
                }
            });
            while(friendlyNeighbors.size() >= 2) { //Leave 1 around.  The one with fewest fire.
                friendlyNeighbors.remove(surroundingBuildingsOnFire.get(0));
                surroundingBuildingsOnFire.remove(0);
            }
        }

        Map.Entry<Building, WeatherStationUtilities.CardinalDirection> firelessDirection = friendlyNeighbors.entrySet().iterator().next();
        Pair<Building, WeatherStationUtilities.CardinalDirection> cardinalBuilding;

        if(firelessDirection.getValue().name().equals("south")) {
            cardinalBuilding = new Pair<>(enemyHeadquarters.buildingSouth, WeatherStationUtilities.CardinalDirection.south);
        } else if(firelessDirection.getValue().name().equals("north")) {
            cardinalBuilding = new Pair<>(enemyHeadquarters.buildingNorth, WeatherStationUtilities.CardinalDirection.north);
        } else if(firelessDirection.getValue().name().equals("west")) {
            cardinalBuilding = new Pair<>(enemyHeadquarters.buildingEast, WeatherStationUtilities.CardinalDirection.east);
        } else {
            cardinalBuilding = new Pair<>(enemyHeadquarters.buildingWest, WeatherStationUtilities.CardinalDirection.west);
        }

//        Map<Building, WeatherStationUtilities.CardinalDirection> buildings = enemyHeadquartersUtilities.getEnemyHeadquartersNeighbors();
        String nextDirection = weatherStationUtilities.getNextWeather().direction;
//
//        //Do NOT light our own HQ on fire!
//        if(buildings.get(myHeadquarters) != null) {
//            buildings.remove(myHeadquarters);
//        }
//
        String correctDirection = weatherStationUtilities.getOppositeOf(cardinalBuilding.getValue());
        boolean directionNeedsChanging = !(cardinalBuilding.getValue().name().equals(correctDirection));
//        for (Map.Entry<Building, WeatherStationUtilities.CardinalDirection> currentBuilding : buildings.entrySet()) {
//            if (weatherStationUtilities.isWeatherOpposite(cardinalBuilding.getValue().name(), nextDirection)) {
//                directionNeedsChanging = false;
//                cardinalBuilding = currentBuilding;
//                break;
//            }
//        }

//        List<Building> oneBuilding = enemyHeadquarters.getBuildingsWithinDistance(1);

//        Building targetBuilding = oneBuilding.get(0);

        //IF HQ IS CLOSE ENOUGH, USE IT INSTEAD LOGIC
        //END HQ IS CLOSE ENOUGH LOGIC

        //Get a list of all our warehouses.  Use them to burn buildings around the enemy HQ
        Set<Warehouse> bribeableWarehouses = warehouseUtilities.getBribeableWarehouses();

        while(cardinalBuilding.getKey().fire < 11 && player.bribesRemaining > 0) {
            Warehouse attacker = warehouseUtilities.getClosestWarehouse(cardinalBuilding.getKey(), bribeableWarehouses);
            if(attacker != null) {
                attacker.ignite(cardinalBuilding.getKey());
                bribeableWarehouses.remove(attacker);
            } else {
                break;
            }
        }

        //Change direction first.  Make sure we fan flames correctly
        while(player.bribesRemaining > 0 && directionNeedsChanging && weatherStationUtilities.getNextBribeableWeatherStation() != null) {
             WeatherStationUtilities.WeatherDirection direction = weatherStationUtilities.getDirection(weatherStationUtilities.getNextWeather().direction,
                    weatherStationUtilities.getOppositeOf(cardinalBuilding.getValue()));
            if(direction.equals(WeatherStationUtilities.WeatherDirection.Backward)) {
                System.out.println("WeatherStation opposite value: " + weatherStationUtilities.getOppositeOf(cardinalBuilding.getValue()));
                System.out.println("Next Direction: " + weatherStationUtilities.getNextWeather().direction);
                System.out.println("Rotating clockwise");
                weatherStationUtilities.getNextBribeableWeatherStation().rotate();
            } else if(direction.equals(WeatherStationUtilities.WeatherDirection.Clockwise)) {
                System.out.println("WeatherStation opposite value: " + weatherStationUtilities.getOppositeOf(cardinalBuilding.getValue()));
                System.out.println("Next Direction: " + weatherStationUtilities.getNextWeather().direction);
                System.out.println("Rotating clockwise.");
                weatherStationUtilities.getNextBribeableWeatherStation().rotate();
                directionNeedsChanging = false;
            } else if (direction.equals(WeatherStationUtilities.WeatherDirection.CounterClockwise)) {
                System.out.println("WeatherStation opposite value: " + weatherStationUtilities.getOppositeOf(cardinalBuilding.getValue()));
                System.out.println("Next Direction: " + weatherStationUtilities.getNextWeather().direction);
                System.out.println("Rotating counterclockwise");
                weatherStationUtilities.getNextBribeableWeatherStation().rotate(true);
                directionNeedsChanging = false;
            } else {
                break;
            }
        }

        //Intensify as much as possible
        while(player.bribesRemaining > 0 && weatherStationUtilities.getNextWeather().intensity < 10 && weatherStationUtilities.getNextBribeableWeatherStation() != null) {
            weatherStationUtilities.getNextBribeableWeatherStation().intensify();
        }

        //First priority: Raid the enemy HQ if it would be useful to dish out extra pain
        if(player.bribesRemaining > 0 && policeDepartmentUtilities.atLeastOnePoliceStationStanding() && enemyHeadquarters.exposure > 0) {
            policeDepartmentUtilities.getFirstStandingPoliceStation().raid(enemyHeadquarters);
        }

        //Increase other fires around enemy HQ


        //Last priority: Play defensive and see if we can fire department away some of burn that's hurting us.
        if(player.bribesRemaining > 0) {
            System.out.println("Calling the firefighters!");
            fireExtinguishAroundHQ(player.bribesRemaining);
        }

        return cardinalBuilding.getKey();

        // Check if fire would hurt our HQ and use it the Fire Department to put out fires
    }

    public Boolean attackUsingNearestWarehouse(Building target){
        Warehouse myAttacker = warehouseUtilities.getClosestWarehouse(target, myAttackers);
        if(myAttacker != null){
            player.log(myAttacker.id + " : " + target.id);
            myAttacker.ignite(target);
            myAttackers.remove(myAttacker);
            return true;
        }
        return false;
    }

    /**
     * Tries to extinguish flames in the direction opposite of the next forecast(first)
     * Then goes for the largest buildings (next)
     * @param bribesToUse
     * @return number of turns used
     */
    public int fireExtinguishAroundHQ(int bribesToUse) {
        //first get HQ
        Warehouse ourHQ = player.headquarters;
        int bribesLeft = Math.min(bribesToUse, player.bribesRemaining);
        int bribesUsed = 0;

        if (bribesLeft <= 0) {
            return 0;
        }

        Stack<FireDepartment> fireDepartments = new Stack<>();

        for (FireDepartment fdpt : player.fireDepartments) {
            if (fdpt != null && fdpt.bribed == false && fdpt.health > 0) {
                fireDepartments.push(fdpt);
            }
        }

        //get the wind direction
        WeatherStationUtilities.CardinalDirection dir = Enum.valueOf(WeatherStationUtilities.CardinalDirection.class, game.nextForecast.direction);
        dir = dir.rotate180();

        //get the building in the opposite direction
        Building adjacentUpwindBuilding = ourHQ.getAdjacentBuilding(dir);
        if (adjacentUpwindBuilding != null && adjacentUpwindBuilding.owner == player) {
            int numberOfExtinguishes = adjacentUpwindBuilding.fire/2;

            int numberOfTurnsToUse = Math.min(bribesLeft, numberOfExtinguishes);
            numberOfTurnsToUse = Math.min(numberOfTurnsToUse, fireDepartments.size());

            for (int bribes = 0; bribes < numberOfTurnsToUse; bribes++) {
                if (fireDepartments.isEmpty() || bribesLeft <= 0) {
                    return bribesUsed;
                }
                FireDepartment dpt = fireDepartments.pop();
                dpt.extinguish(adjacentUpwindBuilding);
                bribesUsed++;
                bribesLeft--;
            }
        }


        //now evenly use the other 3 buildings
        List<Building> adjacentUrgentBuildings = new ArrayList<>();
        List<Building> closeBuildings = ourHQ.getBuildingsWithinDistance(1);
        for (Building b : closeBuildings) {
            if (b != null && b.owner == player && b.fire > 1) {
                adjacentUrgentBuildings.add(b);
            }
        }

        if (bribesLeft <= 0 || adjacentUrgentBuildings.isEmpty()) {
            return bribesUsed;
        }

        while (bribesLeft >= 0) {
            //find the highest fire building
            Building highestFire = adjacentUrgentBuildings.get(0);

            for (Building b : adjacentUrgentBuildings) {
                if (b.fire > highestFire.fire) {
                    highestFire = b;
                }
            }

            if (highestFire.fire <= 1 || fireDepartments.empty()) {
                return bribesUsed;
            }

            //put out the highest fire
            FireDepartment fdpt = fireDepartments.pop();
            fdpt.extinguish(highestFire);
            bribesLeft--;
            bribesUsed++;
        }


        return bribesUsed;
    }
    /**
     * This is called every time the AI is asked to respond with a command during their turn
     *
     * @return represents if you want to end your turn. true means end the turn, false means to keep your turn going and re-call runTurn()
     */
    public boolean runTurn() {
        myAttackers = warehouseUtilities.getHealthyAndUnbribed(player.warehouses);
        enemyAttackers =  warehouseUtilities.getHealthyAndUnbribed(player.otherPlayer.warehouses);
        //joeFiddle();
//        jeffWeather2();
//        jeffWeather();
        georgeFiddle();


//        // <<-- Creer-Merge: runTurn -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
//        // Put your game logic here for runTurn
//
//        //Get my first warehouse
//        Warehouse warehouse = player.warehouses.get(0);
//        if(canBeBribed(warehouse)) {
//            //ignite the first enemy building unless it's a headquarters
//            Building target = player.otherPlayer.buildings.get(0);
//            if(!target.isHeadquarters) {
//                warehouse.ignite(target);
//            }
//        }
//
//        //Get my frst fire department
//        FireDepartment fireDept = player.fireDepartments.get(0);
//        if(canBeBribed(fireDept)) {
//            Building target = player.otherPlayer.buildings.get(0);
//            if(!target.isHeadquarters) {
//                fireDept.extinguish(target);
//            }
//        }
//
//        //Get my first police station
//        PoliceDepartment police = player.policeDepartments.get(0);
//        if(canBeBribed(police)) {
//            //pick an enemy warehouse and raid it
//            Warehouse target = player.otherPlayer.warehouses.get(0);
//            //only raid if it is alive
//            if(target.health > 0) {
//                police.raid(target);
//            }
//        }
//
//        //get first weather station
//        WeatherStation intensifier = player.weatherStations.get(0);
//        if(canBeBribed(intensifier)) {
//
//            if(game.nextForecast.intensity < game.maxForecastIntensity) {
//                //only increase if intensity of weather is currently less than max
//                intensifier.intensify();
//            } else {
//                //otherwise pass true to decrease
//                intensifier.intensify(true);
//            }
//        }
//
//        //get second weather station
//        WeatherStation rotater = player.weatherStations.get(1);
//        if(canBeBribed(rotater)) {
//            //rotate weather clockwise (pass false to go counterclockwise)
//            rotater.rotate();
//        }

        return true;
        // <<-- /Creer-Merge: runTurn -->>
    }

    public void igniteTargetsUsingClosestWarehouses(List<Building> targets, List<Warehouse> myWarehouses, int bribesToSpend){
        Map<Warehouse, Building> targetsForWarehouses = warehouseUtilities.getTargetsForWarehouses(targets, myWarehouses, bribesToSpend);
        for(Map.Entry<Warehouse, Building> entry : targetsForWarehouses.entrySet()){
            entry.getKey().ignite(entry.getValue());
        }
    }
    // <<-- Creer-Merge: methods -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
    // you can add additional methods here for your AI to call

    //add your own methods to the ai!
    public boolean canBeBribed(Building building) {
        return (building.health > 0) && !building.bribed && (building.owner == player);
    }
    // <<-- /Creer-Merge: methods -->>
}
